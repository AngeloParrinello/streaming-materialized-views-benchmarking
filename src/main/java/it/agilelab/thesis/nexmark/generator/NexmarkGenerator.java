package it.agilelab.thesis.nexmark.generator;

import it.agilelab.thesis.nexmark.generator.model.AuctionGenerator;
import it.agilelab.thesis.nexmark.generator.model.BidGenerator;
import it.agilelab.thesis.nexmark.generator.model.PersonGenerator;
import it.agilelab.thesis.nexmark.model.Event;
import it.agilelab.thesis.nexmark.model.NextEvent;

import java.io.Serializable;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Random;

import static java.util.Objects.requireNonNull;

/**
 * A generator for synthetic events. We try to make the data vaguely reasonable. We also ensure most
 * primary key/foreign key relations are correct. Eg: a {@link it.agilelab.thesis.nexmark.model.Bid} event will
 * usually have valid auction and bidder ids which can be joined to already-generated Auction and Person events.
 * <p>
 * To help with testing, we generate timestamps relative to a given {@code baseTime}. Each new
 * event is given a timestamp advanced from the previous timestamp by {@code interEventDelayUs} (in
 * microseconds). The event stream is thus fully deterministic and does not depend on wallclock
 * time.
 */
public class NexmarkGenerator implements Iterator<NextEvent>, Serializable {
    private final Random random;
    /**
     * Configuration to generate events against. Note that it may be replaced by a call to {@link
     * #splitAtEventId}.
     * <p>
     * Note that this is not final because we may replace it with a new config when we split the generator.
     * See {@link #splitAtEventId}.
     */
    private GeneratorConfig config;
    /**
     * Number of events generated by this generator.
     */
    private long eventsCountSoFar;
    /**
     * Wallclock time at which we emitted the first event (ms since epoch). Initially -1.
     */
    private long wallclockBaseTime;

    public NexmarkGenerator(final GeneratorConfig config, final long eventsCountSoFar, final long wallclockBaseTime) {
        requireNonNull(config);
        this.config = config;
        this.eventsCountSoFar = eventsCountSoFar;
        this.wallclockBaseTime = wallclockBaseTime;
        // random generator
        this.random = new Random();
    }

    /**
     * Create a brand-new fresh generator according to {@code config}.
     */
    public NexmarkGenerator(final GeneratorConfig config) {
        this(config, 0, -1);
    }

    /**
     * Return a deep copy of this generator.
     *
     * @return a deep copy of this generator.
     */
    public NexmarkGenerator copy() {
        requireNonNull(this.config);
        return new NexmarkGenerator(this.config, this.eventsCountSoFar, this.wallclockBaseTime);
    }

    /**
     * Mutate this generator so that it will only generate events up to but not including {@code
     * eventId}. Return a config to represent the events this generator will no longer yield. The
     * generators will run in on a serial timeline.
     *
     * @param eventId the event id to split at.
     * @return a config to represent the events this generator will no longer yield.
     */
    public GeneratorConfig splitAtEventId(final long eventId) {
        // Basically, we are subtracting from the eventId the range of events that have
        // already been generated by the Nexmark generator
        long newMaxEvents = eventId - (this.config.getFirstEventId() + this.config.getFirstEventNumber());
        // this configuration represents events that the generator will no longer generate
        GeneratorConfig remainConfig =
                this.config.copyWith(
                        this.config.getFirstEventId(),
                        this.config.getMaxEvents() - newMaxEvents,
                        this.config.getFirstEventNumber() + newMaxEvents);
        this.config = this.config.copyWith(this.config.getFirstEventId(), newMaxEvents, this.config.getFirstEventNumber());
        return remainConfig;
    }

    /**
     * Return the next 'event id'. Though events don't have ids we can simulate them to help with
     * bookkeeping.
     *
     * @return the next 'event id'.
     */
    private long getNextEventId() {
        return this.config.getFirstEventId() + this.config.nextAdjustedEventNumber(this.eventsCountSoFar);
    }

    /**
     * Return the next event. The outer timestamp is in wallclock time and corresponds to when the
     * event should fire. The inner timestamp is in event-time and represents the time the event is
     * purported to have taken place in the simulation.
     * <p>
     * We have these three timestamps because they provide us different pieces of information on when an
     * event should be considered to have occurred in the simulation, declared generated and the warranty
     * until the previous events have been processed.
     *
     * @return the next event.
     */
    private NextEvent nextEvent() {
        if (this.wallclockBaseTime < 0) {
            this.wallclockBaseTime = System.currentTimeMillis();
        }
        // When, in event time, we should generate the event. Monotonic.
        long eventTimestamp = this.config.timestampForEvent(this.config.nextEventNumber(this.eventsCountSoFar));
        // When, in event time, the event should say it was generated. Depending on outOfOrderGroupSize
        // may have local jitter. Used to simulate out-of-order events.
        long adjustedEventTimestamp = this.config.timestampForEvent(this.config.nextAdjustedEventNumber(this.eventsCountSoFar));
        // The minimum of this and all future adjusted event timestamps. Accounts for jitter in
        // the event timestamp. Used to control the progress of the events.
        long watermark = this.config.timestampForEvent(this.config.nextEventNumberForWatermark(this.eventsCountSoFar));
        // When, in wallclock time, we should emit the event.
        long wallclockTimestamp = this.wallclockBaseTime + (eventTimestamp - this.config.getBaseTime());

        long newEventId = getNextEventId();
        long rem = newEventId % this.config.getTotalProportion();

        Event<?> event;
        if (rem < config.getPersonProportion()) {
            event =
                    new Event<>(PersonGenerator.nextPerson(newEventId, random, adjustedEventTimestamp, config));
        } else if (rem < config.getPersonProportion() + config.getAuctionProportion()) {
            event =
                    new Event<>(
                            AuctionGenerator.nextAuction(eventsCountSoFar, newEventId, random, adjustedEventTimestamp, config));
        } else {
            event = new Event<>(BidGenerator.nextBid(newEventId, random, adjustedEventTimestamp, config));
        }

        this.eventsCountSoFar++;
        return new NextEvent(wallclockTimestamp, adjustedEventTimestamp, event, watermark);
    }

    /**
     * Override the Iterator interface to return the next event. Basically, in its implementation, it
     * calls the {@link #nextEvent()} method.
     *
     * @return the next event.
     */
    @Override
    public NextEvent next() {
        if (!hasNext()) {
            throw new NoSuchElementException();
        }
        return nextEvent();
    }

    /**
     * Override the Iterator interface to check if there are more events to generate.
     *
     * @return true if there are more events to generate, false otherwise.
     */
    @Override
    public boolean hasNext() {
        return this.eventsCountSoFar < this.config.getMaxEvents();
    }

    /**
     * Override the Iterator interface to remove the next event. It is not supported.
     */
    @Override
    public void remove() {
        throw new UnsupportedOperationException();
    }

    /**
     * Return an estimate of fraction of output consumed.
     *
     * @return the fraction of output consumed.
     */
    public double getFractionConsumed() {
        return (double) this.eventsCountSoFar / this.config.getMaxEvents();
    }

    /**
     * Return the current config for this generator. Note that configs may be replaced by {@link
     * #splitAtEventId}.
     */
    public GeneratorConfig getCurrentConfig() {
        return this.config;
    }

    /**
     * Gets Number of events generated by this generator.
     *
     * @return the number of events generated by this generator.
     */
    public long getEventsCountSoFar() {
        return this.eventsCountSoFar;
    }

    /**
     * Gets Wallclock time at which we emitted the first event (ms since epoch). Initially -1.
     *
     * @return the wallclock time at which we emitted the first event (ms since epoch). Initially -1.
     */
    public long getWallclockBaseTime() {
        return this.wallclockBaseTime;
    }

    /**
     * Generated toString method, used to print object's internal value.
     *
     * @return the string related to the object.
     */
    @Override
    public String toString() {
        return String.format(
                "Generator{config:%s; eventsCountSoFar:%d; wallclockBaseTime:%d}",
                this.config, this.eventsCountSoFar, this.wallclockBaseTime);
    }
}
