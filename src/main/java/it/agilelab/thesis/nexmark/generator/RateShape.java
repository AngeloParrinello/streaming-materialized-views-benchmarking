package it.agilelab.thesis.nexmark.generator;

/**
 * Shape of event rate.
 */
public enum RateShape {
    /**
     * Square rate.
     */
    SQUARE,
    /**
     * Sinusoidal wave rate.
     */
    SINE;

    /**
     * Number of steps used to approximate sine wave.
     */
    private static final int N = 10;

    /**
     * Returns inter-event delay, in microseconds, for each generator to follow in order to achieve
     * {@code rate} at {@code unit} using {@code numGenerators}.
     *
     * @param rate          rate, the rate of the stream events
     * @param unit          rate unit, the unit of the rate
     * @param numGenerators number of generators to use
     */
    public long interEventDelayUs(final int rate, final RateUnit unit, final int numGenerators) {
        return unit.rateToPeriodUs(rate) * numGenerators;
    }

    /**
     * Returns an array of successive inter-event delays, in microseconds, for each generator to follow
     * in order to achieve this shape with {@code firstRate/nextRate} at {@code unit} using {@code
     * numGenerators}.
     *
     * @param firstRate     first rate, initial rate
     * @param nextRate      next rate, the following rate after the first one
     * @param unit          rate unit, the unit of the rate
     * @param numGenerators number of generators to use
     * @return an array of successive inter-event delays, in microseconds, for each generator to follow.
     */
    public long[] interEventDelayUs(final int firstRate,
                                    final int nextRate,
                                    final RateUnit unit,
                                    final int numGenerators) {
        if (firstRate == nextRate) {
            return new long[]{interEventDelayUs(firstRate, unit, numGenerators)};
        }

        if (this == SQUARE) {
            return new long[]{interEventDelayUs(firstRate, unit, numGenerators),
                    interEventDelayUs(nextRate, unit, numGenerators)};
        } else {
            // medium value between firstRate and nextRate
            double mid = (firstRate + nextRate) / 2.0;
            // amplitude of the sine wave
            double amp = (firstRate - nextRate) / 2.0; // may be -ve
            long[] interEventDelayUs = new long[N];
            for (int i = 0; i < N; i++) {
                double r = (2.0 * Math.PI * i) / N;
                // represents a sinusoidal value between firstRate and nextRate
                double rate = mid + amp * Math.cos(r);
                interEventDelayUs[i] = unit.rateToPeriodUs(Math.round(rate)) * numGenerators;
            }
            return interEventDelayUs;
        }
    }

    /**
     * Returns delay between steps, in seconds, for result of {@link #interEventDelayUs}, to
     * cycle through the entire sequence every {@code ratePeriodSec}.
     * <p>
     * The method returns the delay (in seconds) between the next steps within the full sequence of delays generated by
     * the {@link #interEventDelayUs} method. The goal is to make sure that the entire sequence
     * is cycled through each time period specified by {@code ratePeriodSec}.
     *
     * @param ratePeriodSec the rate period in seconds, desired time period to complete the entire sequence of delays
     * @return the step length in seconds
     */
    public int stepLengthSec(final int ratePeriodSec) {
        // number of steps
        int n;
        if (this == SQUARE) {
            n = 2;
        } else {
            n = N;
        }
        // With (ratePeriodSec + n - 1) ensures that we get the correct rounding up in case an exact division does not occur
        // basically, calculates the number of steps that fit into the rate period or in other word
        // the delay between steps
        return (ratePeriodSec + n - 1) / n;
    }
}
